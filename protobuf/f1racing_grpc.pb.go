// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.2
// source: k5_proto/proto/f1racing.proto

package protobufpb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// F1RacingSvcClient is the client API for F1RacingSvc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type F1RacingSvcClient interface {
	RaceCreate(ctx context.Context, in *RaceCreateReq, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RaceResultUpdated(ctx context.Context, in *RaceResultUpdatedReq, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RaceCancelled(ctx context.Context, in *RaceCancelledReq, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RewardGranted(ctx context.Context, in *RewardGrantedReq, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RaceRegistered(ctx context.Context, in *RaceRegisteredReq, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type f1RacingSvcClient struct {
	cc grpc.ClientConnInterface
}

func NewF1RacingSvcClient(cc grpc.ClientConnInterface) F1RacingSvcClient {
	return &f1RacingSvcClient{cc}
}

func (c *f1RacingSvcClient) RaceCreate(ctx context.Context, in *RaceCreateReq, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/protobuf.F1racingSvc/RaceCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *f1RacingSvcClient) RaceResultUpdated(ctx context.Context, in *RaceResultUpdatedReq, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/protobuf.F1racingSvc/RaceResultUpdated", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *f1RacingSvcClient) RaceCancelled(ctx context.Context, in *RaceCancelledReq, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/protobuf.F1racingSvc/RaceCancelled", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *f1RacingSvcClient) RewardGranted(ctx context.Context, in *RewardGrantedReq, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/protobuf.F1racingSvc/RewardGranted", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *f1RacingSvcClient) RaceRegistered(ctx context.Context, in *RaceRegisteredReq, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/protobuf.F1racingSvc/RaceRegistered", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// F1RacingSvcServer is the server API for F1RacingSvc service.
// All implementations must embed UnimplementedF1RacingSvcServer
// for forward compatibility
type F1RacingSvcServer interface {
	RaceCreate(context.Context, *RaceCreateReq) (*emptypb.Empty, error)
	RaceResultUpdated(context.Context, *RaceResultUpdatedReq) (*emptypb.Empty, error)
	RaceCancelled(context.Context, *RaceCancelledReq) (*emptypb.Empty, error)
	RewardGranted(context.Context, *RewardGrantedReq) (*emptypb.Empty, error)
	RaceRegistered(context.Context, *RaceRegisteredReq) (*emptypb.Empty, error)
	mustEmbedUnimplementedF1RacingSvcServer()
}

// UnimplementedF1RacingSvcServer must be embedded to have forward compatible implementations.
type UnimplementedF1RacingSvcServer struct {
}

func (UnimplementedF1RacingSvcServer) RaceCreate(context.Context, *RaceCreateReq) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RaceCreate not implemented")
}
func (UnimplementedF1RacingSvcServer) RaceResultUpdated(context.Context, *RaceResultUpdatedReq) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RaceResultUpdated not implemented")
}
func (UnimplementedF1RacingSvcServer) RaceCancelled(context.Context, *RaceCancelledReq) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RaceCancelled not implemented")
}
func (UnimplementedF1RacingSvcServer) RewardGranted(context.Context, *RewardGrantedReq) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RewardGranted not implemented")
}
func (UnimplementedF1RacingSvcServer) RaceRegistered(context.Context, *RaceRegisteredReq) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RaceRegistered not implemented")
}
func (UnimplementedF1RacingSvcServer) mustEmbedUnimplementedF1RacingSvcServer() {}

// UnsafeF1RacingSvcServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to F1RacingSvcServer will
// result in compilation errors.
type UnsafeF1RacingSvcServer interface {
	mustEmbedUnimplementedF1RacingSvcServer()
}

func RegisterF1RacingSvcServer(s grpc.ServiceRegistrar, srv F1RacingSvcServer) {
	s.RegisterService(&F1RacingSvc_ServiceDesc, srv)
}

func _F1RacingSvc_RaceCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RaceCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(F1RacingSvcServer).RaceCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.F1racingSvc/RaceCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(F1RacingSvcServer).RaceCreate(ctx, req.(*RaceCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _F1RacingSvc_RaceResultUpdated_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RaceResultUpdatedReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(F1RacingSvcServer).RaceResultUpdated(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.F1racingSvc/RaceResultUpdated",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(F1RacingSvcServer).RaceResultUpdated(ctx, req.(*RaceResultUpdatedReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _F1RacingSvc_RaceCancelled_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RaceCancelledReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(F1RacingSvcServer).RaceCancelled(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.F1racingSvc/RaceCancelled",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(F1RacingSvcServer).RaceCancelled(ctx, req.(*RaceCancelledReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _F1RacingSvc_RewardGranted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RewardGrantedReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(F1RacingSvcServer).RewardGranted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.F1racingSvc/RewardGranted",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(F1RacingSvcServer).RewardGranted(ctx, req.(*RewardGrantedReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _F1RacingSvc_RaceRegistered_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RaceRegisteredReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(F1RacingSvcServer).RaceRegistered(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.F1racingSvc/RaceRegistered",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(F1RacingSvcServer).RaceRegistered(ctx, req.(*RaceRegisteredReq))
	}
	return interceptor(ctx, in, info, handler)
}

// F1RacingSvc_ServiceDesc is the grpc.ServiceDesc for F1RacingSvc service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var F1RacingSvc_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "protobuf.F1racingSvc",
	HandlerType: (*F1RacingSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RaceCreate",
			Handler:    _F1RacingSvc_RaceCreate_Handler,
		},
		{
			MethodName: "RaceResultUpdated",
			Handler:    _F1RacingSvc_RaceResultUpdated_Handler,
		},
		{
			MethodName: "RaceCancelled",
			Handler:    _F1RacingSvc_RaceCancelled_Handler,
		},
		{
			MethodName: "RewardGranted",
			Handler:    _F1RacingSvc_RewardGranted_Handler,
		},
		{
			MethodName: "RaceRegistered",
			Handler:    _F1RacingSvc_RaceRegistered_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "k5_proto/proto/f1racing.proto",
}
